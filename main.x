;; -*- mode: lisp -*-

(def rep (str)
  (prn (eval (compile (macroexpand (read-from-string str))))))

(def repl ()
  (let (execute (fn (str) (rep str) (write "> ")))
    (write "> ")
    (target
     (js (do (process.stdin.resume)
	     (process.stdin.setEncoding 'utf8)
	     (process.stdin.on 'data execute)))
     (lua (while true
	    (let (str (io.stdin:read))
	      (if str (execute str) break)))))))

(def usage ()
  (prn "usage: x [options] [inputs]")
  (prn "options:")
  (prn "  -o <output>\tOutput file")
  (prn "  -t <target>\tTarget language (default: lua)")
  (prn "  -e <expr>\tExpression to evaluate")
  (prn "  -m \t\tEmbed macro definitions in output")
  (exit))

(def main ()
  (set args (target (js (sub process.argv 2)) (lua arg)))
  (if (or (= (at args 0) "-h")
	  (= (at args 0) "--help"))
      (usage))
  (let (inputs ()
        output nil
        target1 nil
	expr nil)
    (across (args arg i)
      (if (or (= arg "-o") (= arg "-t") (= arg "-e"))
	  (if (= i (- (length args) 1))
	      (prn "missing argument for" arg)
	    (do (set i (+ i 1))
		(let (arg2 (at args i))
		  (if (= arg "-o") (set output arg2)
		      (= arg "-t") (set target1 arg2)
		      (= arg "-e") (set expr arg2)))))
	  (= arg "-m") (set embed-macros? true)
	  (= "-" (sub arg 0 1))
	  (do (prn "unrecognized option:" arg) (usage))
	(push inputs arg)))
    (if output
	(do (if target1 (set target target1))
	    (let (compiled (compile-files inputs)
		  main (compile '(main) true))
	      (write-file output (cat compiled macros main))))
      (do (across (inputs file)
	    (eval (compile-file file)))
	  (if expr (rep expr) (repl))))))
